import { GetVapidPublicKey } from 'appRoot/api/PushData';
import EventBus from 'appRoot/scripts/EventBus';

export function ServiceWorkerInit()
{
	// Set up a service worker to handle incoming push notifications.
	if (appContext.serviceWorkerEnabled)
	{
		if (!('serviceWorker' in navigator))
		{
			console.warn("Service workers are not supported in this browser, therefore PUSH notifications will not be available.");
			return;
		}
		if (!('showNotification' in ServiceWorkerRegistration.prototype))
		{
			console.warn("ServiceWorker Notifications are not supported in this browser, therefore PUSH notifications will not be available.");
			return;
		}
		if (!('PushManager' in window))
		{
			console.warn("Push messaging is not supported in this browser.");
			return;
		}
		navigator.serviceWorker.register('serviceworker/service-worker.js')
			.then(() =>
			{
				EventBus.pushNotificationsAvailable = true;

				navigator.serviceWorker.ready
					.then(function (registration)
					{
						// Use the PushManager to get the user's subscription to the push service.
						return registration.pushManager.getSubscription()
							.then(async function (subscription)
							{
								// If a subscription was found, return it.
								if (subscription)
									return subscription;

								// Get the server's public key
								const response = await GetVapidPublicKey();

								// Old versions of Chrome do not accept the vapidPublicKey as base64.
								const convertedVapidKey = urlBase64ToUint8Array(response.vapidPublicKey);

								// Subscribe the user (userVisibleOnly allows to specify that we don't plan to send notifications that don't have a visible effect for the user).
								return registration.pushManager.subscribe({
									userVisibleOnly: true,
									applicationServerKey: convertedVapidKey
								});
							});
					})
					.then(function (subscription)
					{
						// Send the subscription details to the server using the Fetch API.
						fetch('registerForPush', {
							method: 'post',
							headers: {
								'Content-type': 'application/json'
							},
							body: JSON.stringify({
								subscription: subscription
							}),
						});

						document.getElementById('doIt').onclick = function ()
						{
							const delay = document.getElementById('notification-delay').value;
							const ttl = document.getElementById('notification-ttl').value;

							// Ask the server to send the client a notification (for testing purposes, in actual
							// applications the push notification is likely going to be generated by some event
							// in the server).
							fetch('./sendNotification', {
								method: 'post',
								headers: {
									'Content-type': 'application/json'
								},
								body: JSON.stringify({
									subscription: subscription,
									delay: delay,
									ttl: ttl,
								}),
							});
						};

					})
					.catch(err =>
					{
						toaster.warn(err);
					});
			})
			.catch(err =>
			{
				toaster.warn(err);
			});
	}
}

function urlBase64ToUint8Array(base64String)
{
	var padding = '='.repeat((4 - base64String.length % 4) % 4);
	var base64 = (base64String + padding)
		.replace(/\-/g, '+')
		.replace(/_/g, '/');

	var rawData = window.atob(base64);
	var outputArray = new Uint8Array(rawData.length);

	for (var i = 0; i < rawData.length; ++i)
	{
		outputArray[i] = rawData.charCodeAt(i);
	}
	return outputArray;
}
